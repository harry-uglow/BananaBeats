\documentclass[11pt]{article}

\usepackage{fullpage}

\begin{document}
\sloppy
\title{C Programming Project: BananaBeats}
\author{Group 19: Harry Uglow, Joshua Cooper, Maurice Yap and Shayan Khaksar-Ghalati}

\maketitle

\section{Introduction}

\subsection{Assembler}
\subsubsection{File Structure}
The main function from which the assembler program is run is the sole function in the file, \texttt{assemble.c} and resides in the main \texttt{src/} directory. Its source files are located in the \texttt{assembler/} directory within \texttt{src/}. In addition to this, a range of other supplementary files are located in the \texttt{assembler/} directory including \texttt{utils.c} which contains multiple utility functions that were used in the program. We have also written a \texttt{Makefile} in the \texttt{src/} directory which compiles both our assembler and emulator with the correct dependencies so that the minimal amount of work required is done in the compilation process when files are changed.
\subsubsection{Implementation}
We elected to use the two-pass method to implement the assembler. This meant that we needed to create a Symbol Table data type. This simple and minimal data type uses a linked list of label-pointer pairs and includes the \textit{put} and \textit{get} functions which add a label-pointer pair entry to the table and retrieve a pointer given a label argument respectively. There are also functions included to create a new Symbol Table (\textit{new}) and remove a Symbol Table (\textit{delete}) and all its associated nodes from memory. We decided that the second part of the pair would be a generic pointer (\texttt{void *}) as opposed to an integer pointer as this makes the data structure reuseable for purposes other than mapping labels to memory addresses.\\

In the execution of the assembler program within \texttt{main}, a utility function \texttt{int initialiseAssembler(void)} is first called to allocate heap memory for the instructions to be read from the assembly file (\texttt{instruction} array), the instructions to be encoded (\texttt{memory} array), the Symbol Table (through \texttt{symbolTable\_t *SymbolTable\_new(void)}) as well as to initalise the \texttt{address} counter.\\

On the first pass (\texttt{int firstPass(char **argv)} in \texttt{utils.c}), the input file is read and all labels are added to the Symbol Table along with their corresponding memory address. The instructions (i.e. everthing which is not a label) are split up into tokens and placed into an assembly instruction struct (\texttt{struct assInstr}). The assembly instruction structs are placed into an array (\texttt{instruction}).\\

The second pass (\texttt{void secondPass(void)} in \texttt{utils.c}) iterates through the array of assembly instructions. For each element in the array, the assembly instruction is encoded into a binary instruction and this binary instruction is placed into another array (\texttt{memory}) representing each byte of the output. To do this, it makes use of the supplementary function \texttt{int32\_t encode(assIns\_t *instr)} found in \texttt{encodeInstructions.c}. This function is given a formatted assembly instruction (with the use of \texttt{instr\_t *getFormat(assIns\_t *assIns)}) and encodes the instruction depending on the type of instruction that it is.\\

After the second pass, the encoded instructions are written into the binary file, specified by the caller of the program, with the utility function \texttt{int writeToBinaryFile(char **argv)}. Finally, the arrays for the assembly and encoded binary instructions, the Symbol Table  and other data stored on the heap are removed with the utility function \texttt{void freeInstructions(void)} and \texttt{void SymbolTable\_delete(symbolTable\_t *symbolTable)}.

\subsection{Extension plans}

We came together as a group because we all have an interest in sound and music and wanted to create an extension based around this. The ideas we had included:
\begin{itemize}
\item LED lights synchronised with music
\item Chromatic tuner with LED lights and LCD display
\item Visual equaliser 
\item Touch-pad sound controller 
\end{itemize}
After much discussion, we decided to work on creating a touch-pad keyboard with a GUI. Our aim was to allow users to play pre-defined sounds mapped to 12 different keys and change the sound mapping (or instrument) through the GUI.

\section{The Extension: BananaBeats}
	For the extension we have created a primitive keyboard application for the Raspberry Pi. The application takes input from an Adafruit Capacitive Touch HAT. This allows us to connect 12 wires and use them all as keys for our keyboard. To make our project particularly eye-catching we are using bananas as the keys. At submission time our GUI can select one of three sound sets, or "instruments". The first is a drum kit, the second a set of piano keys and the third is a selection of sound effects from Super Mario Bros. Our application also has a volume slider. We plan on making these features run more smoothly as well as adding more between now and our presentation.
	
\subsection{Design}
	Our design for the GUI was to utilise GTK+ in order to create widgets allowing the user to interact with the program. Our initial aim was to create a simple but functional GUI but we hope to equip it with more features and make it look more interesting before we present next week. 
	\\
	
	The GUI will be initialised from our main function and will make use of auxiliary functions found in \texttt{guiUtils.h} and \texttt{guiUtils.c}. We will use a symbol table for the sound mapping similar to the one we used in Part II. The symbol table interface is found in \texttt{symbolTable.h} and the initialising of the various sound tables can be found in \texttt{initialiser.h} and \texttt{initialiser.c}

\subsection{Challenges}
	One of the biggest challenges we have faced in our extension is managing the multiple sources of input. We want to have our GUI running so that the user can change instrument at the same time as the Python scripts are running and registering input via the Touch HAT. For this reason we have been doing some multi-threading in C to allow these two tasks to be running simultaneously.\\
	
	We have also had to interact between C and Python code, making use of functions that return PyObjects to allow us to compute things that our Python code requires in C. These include fetching the sounds from the symbol table and finding out what the user defined volume should be.

\section{Testing}
	At time of writing we have prioritised trying to get our extension to work as we intend it to over extensive testing of edge cases. As such, the main challenges while seeing if our code runs correctly has been checking what point the code reaches before it stops behaving as expected so for quick and easy debugging and testing we have made use of C's  \texttt{printf()} function. Our extension does not make much use of memory allocation, so we have not needed to track down any memory leaks or segmentation faults thus far.

\subsection{Testing evaluation}
While we think that our lack of proper testing hasn't impeded our ability to complete the extension we think that perhaps in the future creating specific tests for each function may help. It could make pinpointing where the code is failing easier whilst we are still in the implementation phase more easily. However, we think that these sorts of tests may have been difficult to implement in themselves seeing as we make use of complex tools like multi-threading and graphics frameworks in our project.

\section{Reflection}
As a group we always ensured that we were able to reach one another whenever necessary so that we could discuss the work that we were doing. This meant that aside from organising meetings over social media, we also found it easy to help others with any issues they faced without having to be in the same room. Furthermore, as a group we were very careful in ensuring that our commit messages on gitlab were clear and concise throughout the project.\\

At the beginning of each part of the project we found logical ways of splitting up the workload, with Harry tracking everyone's progress to ensure that we were all on target to finish in a reasonable time. In addition to this, we discussed the fundamental code structure for each part, as a group, before we started on our individual tasks. This was vital in ensuring that we all understood how everyones work would link together. Overall, we had a great group dynamic which meant that we cooperated well and helped each other where necessary. \\

In the future we feel we could make use of other organisation tools, so that it was even clearer what our current aims were. Having said this, none of us would have any issues completing another project in the same manner as this one.

\subsection{Harry}
This is the second group project this year in which I have been group leader. I feel like I greatly improved over last time for this project. I was much more proactive at organising meeting times for the group and dividing up the tasks for each part. My WebPA feedback was very positive as well and I think my group would agree with me on the points made above.\\

 I also think I did well in the technical aspects of this project. I worked hard to understand C as fast as possible so that I could help the rest of my group and make sure we kept meeting project milestones in good time. I have been less proficient with the electronics side of this Raspberry Pi project including working to set up the Capacitive Touch HAT for our extension and in the future I will work to make sure I fully understand all aspects of a project.

\subsection{Shayan}
I feel that our team worked extremely well together and ensured that we maintained good communication between one another. After initial discussions on our plan of action, we were allocated specific tasks by our group leader which gave us a concrete path to follow in completing the project. Whilst we all co-operated well and had no issues, I think that one area in which I could have improved was in my competence with and understanding of C since I did not learn it as quickly as I had imagined I would. This occasionally posed difficulties for me in completing the tasks I was allocated. \\

On the other hand, I tried to inspect the code our group had written as carefully as possible to notice any minute problems. In future projects, I plan to spend more time improving my ability with the topic of the project to ensure that I can contribute without any issues.  


\subsection{Josh}
Over the course of this project I feel that I have greatly improved my communication skills, as our group was constantly in touch and discussing different aspects of the tasks at hand. On top of this I also feel like I am a lot more competent now with regards to writing clear and readable code. This is because of the fact that when working in a group you are required to think about how easy it will be for others to read the code that you have written, ensuring that you use concise comments throughout. \\

At the beginning of the project I did however find it hard to get my head around the concept of memory management that is so vital when learning C. This meant that it took me a bit longer than it should have to write what I would class now as fairly simple code. In future projects I will make sure that I spend a sufficient amount of time learning the core concepts of the language I am using so that I am not slowed down by having to repeatedly look back to lecture notes whilst writing my code.

\subsection{Maurice}
Personal reflection

\end{document}
